pipeline {
  agent any
  parameters {
    string(name: 'SOURCE_REPO', defaultValue: 'https://github.com/Aincrad-Flux/RType.git', description: 'URL du repository à cloner')
    string(name: 'BRANCH', defaultValue: 'main', description: 'Branche à builder')
    choice(name: 'BUILD_TYPE', choices: ['Debug', 'Release'], description: 'Type de build')
    booleanParam(name: 'RUN_TESTS', defaultValue: false, description: 'Exécuter les tests si disponibles')
    booleanParam(name: 'RUN_ANALYSIS', defaultValue: true, description: 'Lancer analyse statique')
  }
  options { timestamps(); ansiColor('xterm'); buildDiscarder(logRotator(numToKeepStr: '15')) }
  environment { REPORT_DIR='analysis-reports'; BUILD_DIR='build'; PKG_DIR='package' }
  stages {
    stage('Checkout') { steps { git branch: params.BRANCH, url: params.SOURCE_REPO, credentialsId: 'github-https-token' } }
    stage('Dependencies') { steps { sh 'set -e; mkdir -p ${BUILD_DIR}; cd ${BUILD_DIR}; conan profile detect --force || true; conan install .. --build=missing -s build_type=${BUILD_TYPE}' } }
    stage('Configure') { steps { sh 'set -e; cd ${BUILD_DIR}; cmake -DCMAKE_BUILD_TYPE=${BUILD_TYPE} -DCMAKE_EXPORT_COMPILE_COMMANDS=ON ..; cp compile_commands.json .. || true' } }
    stage('Build') { steps { sh 'set -e; cd ${BUILD_DIR}; cmake --build . --config ${BUILD_TYPE} -j$(nproc 2>/dev/null || sysctl -n hw.ncpu)' } }
    stage('Tests') {
      when { expression { return params.RUN_TESTS } }
      steps { sh 'set -e; cd ${BUILD_DIR}; if command -v ctest >/dev/null 2>&1; then ctest --output-on-failure -C ${BUILD_TYPE} || true; else echo "ctest absent"; fi' }
    }
    stage('Static Analysis') {
      when { expression { return params.RUN_ANALYSIS } }
      steps {
        sh '''
          set -e
          mkdir -p ${REPORT_DIR}
          if command -v cppcheck >/dev/null 2>&1; then
            cppcheck --enable=warning,performance,portability,style --inconclusive --std=c++17 \
              --project=compile_commands.json --suppress=missingIncludeSystem 2> ${REPORT_DIR}/cppcheck.txt || true
          else
            echo 'cppcheck absent'
          fi
          if command -v clang-tidy >/dev/null 2>&1; then
            FILES=$(jq -r '.[].file' compile_commands.json 2>/dev/null | grep -E '\\.(cpp|cxx|cc)$' | head -n 50)
            for f in $FILES; do clang-tidy "$f" -- -std=c++17 >> ${REPORT_DIR}/clang-tidy.txt 2>&1 || true; done
          else
            echo 'clang-tidy absent'
          fi
        '''
      }
    }
    stage('Package') {
      steps {
        sh '''
          set -e
          rm -rf ${PKG_DIR}
            mkdir -p ${PKG_DIR}/bin ${PKG_DIR}/docs
            find ${BUILD_DIR} -maxdepth 3 -type f -perm +111 -print -exec cp {} ${PKG_DIR}/bin/ \; 2>/dev/null || true
            cp -a README.md ${PKG_DIR}/docs/ 2>/dev/null || true
            cp -a subject.md ${PKG_DIR}/docs/ 2>/dev/null || true
            echo "BuildType=${BUILD_TYPE}" > ${PKG_DIR}/BUILD_INFO
        '''
      }
    }
    stage('Archive Package') {
      steps {
        script { env.ARCHIVE_NAME = "rtype-full-${BRANCH}-${BUILD_TYPE}-" + new Date().format('yyyyMMdd_HHmmss') + '.tar.gz' }
        sh 'tar -czf ${ARCHIVE_NAME} ${PKG_DIR}'
      }
    }
  }
  post {
    success {
      archiveArtifacts artifacts: '${BUILD_DIR}/**', allowEmptyArchive: true
      archiveArtifacts artifacts: '${REPORT_DIR}/**', allowEmptyArchive: true
      archiveArtifacts artifacts: '*.tar.gz', fingerprint: true
    }
    always { cleanWs(cleanWhenAborted: true, deleteDirs: true) }
  }
}
